# gcc -E kern/pmap.c  -DJOS_KERNEL -I/mnt/e/sec/6.828/lab
# 0 "kern/pmap.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "kern/pmap.c"


# 1 "/mnt/e/sec/6.828/lab/inc/x86.h" 1



# 1 "/mnt/e/sec/6.828/lab/inc/types.h" 1
# 9 "/mnt/e/sec/6.828/lab/inc/types.h"
typedef _Bool bool;
enum { false, true };


typedef __signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned int uint32_t;
typedef long long int64_t;
typedef unsigned long long uint64_t;





typedef int32_t intptr_t;
typedef uint32_t uintptr_t;
typedef uint32_t physaddr_t;


typedef uint32_t ppn_t;


typedef uint32_t size_t;


typedef int32_t ssize_t;


typedef int32_t off_t;
# 5 "/mnt/e/sec/6.828/lab/inc/x86.h" 2

static inline void
breakpoint(void)
{
 asm volatile("int3");
}

static inline uint8_t
inb(int port)
{
 uint8_t data;
 asm volatile("inb %w1,%0" : "=a" (data) : "d" (port));
 return data;
}

static inline void
insb(int port, void *addr, int cnt)
{
 asm volatile("cld\n\trepne\n\tinsb"
       : "=D" (addr), "=c" (cnt)
       : "d" (port), "0" (addr), "1" (cnt)
       : "memory", "cc");
}

static inline uint16_t
inw(int port)
{
 uint16_t data;
 asm volatile("inw %w1,%0" : "=a" (data) : "d" (port));
 return data;
}

static inline void
insw(int port, void *addr, int cnt)
{
 asm volatile("cld\n\trepne\n\tinsw"
       : "=D" (addr), "=c" (cnt)
       : "d" (port), "0" (addr), "1" (cnt)
       : "memory", "cc");
}

static inline uint32_t
inl(int port)
{
 uint32_t data;
 asm volatile("inl %w1,%0" : "=a" (data) : "d" (port));
 return data;
}

static inline void
insl(int port, void *addr, int cnt)
{
 asm volatile("cld\n\trepne\n\tinsl"
       : "=D" (addr), "=c" (cnt)
       : "d" (port), "0" (addr), "1" (cnt)
       : "memory", "cc");
}

static inline void
outb(int port, uint8_t data)
{
 asm volatile("outb %0,%w1" : : "a" (data), "d" (port));
}

static inline void
outsb(int port, const void *addr, int cnt)
{
 asm volatile("cld\n\trepne\n\toutsb"
       : "=S" (addr), "=c" (cnt)
       : "d" (port), "0" (addr), "1" (cnt)
       : "cc");
}

static inline void
outw(int port, uint16_t data)
{
 asm volatile("outw %0,%w1" : : "a" (data), "d" (port));
}

static inline void
outsw(int port, const void *addr, int cnt)
{
 asm volatile("cld\n\trepne\n\toutsw"
       : "=S" (addr), "=c" (cnt)
       : "d" (port), "0" (addr), "1" (cnt)
       : "cc");
}

static inline void
outsl(int port, const void *addr, int cnt)
{
 asm volatile("cld\n\trepne\n\toutsl"
       : "=S" (addr), "=c" (cnt)
       : "d" (port), "0" (addr), "1" (cnt)
       : "cc");
}

static inline void
outl(int port, uint32_t data)
{
 asm volatile("outl %0,%w1" : : "a" (data), "d" (port));
}

static inline void
invlpg(void *addr)
{
 asm volatile("invlpg (%0)" : : "r" (addr) : "memory");
}

static inline void
lidt(void *p)
{
 asm volatile("lidt (%0)" : : "r" (p));
}

static inline void
lgdt(void *p)
{
 asm volatile("lgdt (%0)" : : "r" (p));
}

static inline void
lldt(uint16_t sel)
{
 asm volatile("lldt %0" : : "r" (sel));
}

static inline void
ltr(uint16_t sel)
{
 asm volatile("ltr %0" : : "r" (sel));
}

static inline void
lcr0(uint32_t val)
{
 asm volatile("movl %0,%%cr0" : : "r" (val));
}

static inline uint32_t
rcr0(void)
{
 uint32_t val;
 asm volatile("movl %%cr0,%0" : "=r" (val));
 return val;
}

static inline uint32_t
rcr2(void)
{
 uint32_t val;
 asm volatile("movl %%cr2,%0" : "=r" (val));
 return val;
}

static inline void
lcr3(uint32_t val)
{
 asm volatile("movl %0,%%cr3" : : "r" (val));
}

static inline uint32_t
rcr3(void)
{
 uint32_t val;
 asm volatile("movl %%cr3,%0" : "=r" (val));
 return val;
}

static inline void
lcr4(uint32_t val)
{
 asm volatile("movl %0,%%cr4" : : "r" (val));
}

static inline uint32_t
rcr4(void)
{
 uint32_t cr4;
 asm volatile("movl %%cr4,%0" : "=r" (cr4));
 return cr4;
}

static inline void
tlbflush(void)
{
 uint32_t cr3;
 asm volatile("movl %%cr3,%0" : "=r" (cr3));
 asm volatile("movl %0,%%cr3" : : "r" (cr3));
}

static inline uint32_t
read_eflags(void)
{
 uint32_t eflags;
 asm volatile("pushfl; popl %0" : "=r" (eflags));
 return eflags;
}

static inline void
write_eflags(uint32_t eflags)
{
 asm volatile("pushl %0; popfl" : : "r" (eflags));
}

static inline uint32_t
read_ebp(void)
{
 uint32_t ebp;
 asm volatile("movl %%ebp,%0" : "=r" (ebp));
 return ebp;
}

static inline uint32_t
read_esp(void)
{
 uint32_t esp;
 asm volatile("movl %%esp,%0" : "=r" (esp));
 return esp;
}

static inline void
cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
{
 uint32_t eax, ebx, ecx, edx;
 asm volatile("cpuid"
       : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
       : "a" (info));
 if (eaxp)
  *eaxp = eax;
 if (ebxp)
  *ebxp = ebx;
 if (ecxp)
  *ecxp = ecx;
 if (edxp)
  *edxp = edx;
}

static inline uint64_t
read_tsc(void)
{
 uint64_t tsc;
 asm volatile("rdtsc" : "=A" (tsc));
 return tsc;
}

static inline uint32_t
xchg(volatile uint32_t *addr, uint32_t newval)
{
 uint32_t result;


 asm volatile("lock; xchgl %0, %1"
       : "+m" (*addr), "=a" (result)
       : "1" (newval)
       : "cc");
 return result;
}
# 4 "kern/pmap.c" 2
# 1 "/mnt/e/sec/6.828/lab/inc/mmu.h" 1
# 152 "/mnt/e/sec/6.828/lab/inc/mmu.h"
struct Segdesc {
 unsigned sd_lim_15_0 : 16;
 unsigned sd_base_15_0 : 16;
 unsigned sd_base_23_16 : 8;
 unsigned sd_type : 4;
 unsigned sd_s : 1;
 unsigned sd_dpl : 2;
 unsigned sd_p : 1;
 unsigned sd_lim_19_16 : 4;
 unsigned sd_avl : 1;
 unsigned sd_rsv1 : 1;
 unsigned sd_db : 1;
 unsigned sd_g : 1;
 unsigned sd_base_31_24 : 8;
};
# 215 "/mnt/e/sec/6.828/lab/inc/mmu.h"
struct Taskstate {
 uint32_t ts_link;
 uintptr_t ts_esp0;
 uint16_t ts_ss0;
 uint16_t ts_padding1;
 uintptr_t ts_esp1;
 uint16_t ts_ss1;
 uint16_t ts_padding2;
 uintptr_t ts_esp2;
 uint16_t ts_ss2;
 uint16_t ts_padding3;
 physaddr_t ts_cr3;
 uintptr_t ts_eip;
 uint32_t ts_eflags;
 uint32_t ts_eax;
 uint32_t ts_ecx;
 uint32_t ts_edx;
 uint32_t ts_ebx;
 uintptr_t ts_esp;
 uintptr_t ts_ebp;
 uint32_t ts_esi;
 uint32_t ts_edi;
 uint16_t ts_es;
 uint16_t ts_padding4;
 uint16_t ts_cs;
 uint16_t ts_padding5;
 uint16_t ts_ss;
 uint16_t ts_padding6;
 uint16_t ts_ds;
 uint16_t ts_padding7;
 uint16_t ts_fs;
 uint16_t ts_padding8;
 uint16_t ts_gs;
 uint16_t ts_padding9;
 uint16_t ts_ldt;
 uint16_t ts_padding10;
 uint16_t ts_t;
 uint16_t ts_iomb;
};


struct Gatedesc {
 unsigned gd_off_15_0 : 16;
 unsigned gd_sel : 16;
 unsigned gd_args : 5;
 unsigned gd_rsv1 : 3;
 unsigned gd_type : 4;
 unsigned gd_s : 1;
 unsigned gd_dpl : 2;
 unsigned gd_p : 1;
 unsigned gd_off_31_16 : 16;
};
# 310 "/mnt/e/sec/6.828/lab/inc/mmu.h"
struct Pseudodesc {
 uint16_t pd_lim;
 uint32_t pd_base;
} __attribute__ ((packed));
# 5 "kern/pmap.c" 2
# 1 "/mnt/e/sec/6.828/lab/inc/error.h" 1





enum {

 E_UNSPECIFIED = 1,
 E_BAD_ENV ,

 E_INVAL ,
 E_NO_MEM ,
 E_NO_FREE_ENV ,

 E_FAULT ,

 MAXERROR
};
# 6 "kern/pmap.c" 2
# 1 "/mnt/e/sec/6.828/lab/inc/string.h" 1





int strlen(const char *s);
int strnlen(const char *s, size_t size);
char * strcpy(char *dst, const char *src);
char * strncpy(char *dst, const char *src, size_t size);
char * strcat(char *dst, const char *src);
size_t strlcpy(char *dst, const char *src, size_t size);
int strcmp(const char *s1, const char *s2);
int strncmp(const char *s1, const char *s2, size_t size);
char * strchr(const char *s, char c);
char * strfind(const char *s, char c);

void * memset(void *dst, int c, size_t len);
void * memcpy(void *dst, const void *src, size_t len);
void * memmove(void *dst, const void *src, size_t len);
int memcmp(const void *s1, const void *s2, size_t len);
void * memfind(const void *s, int c, size_t len);

long strtol(const char *s, char **endptr, int base);
# 7 "kern/pmap.c" 2
# 1 "/mnt/e/sec/6.828/lab/inc/assert.h" 1





# 1 "/mnt/e/sec/6.828/lab/inc/stdio.h" 1



# 1 "/mnt/e/sec/6.828/lab/inc/stdarg.h" 1





typedef __builtin_va_list va_list;
# 5 "/mnt/e/sec/6.828/lab/inc/stdio.h" 2






void cputchar(int c);
int getchar(void);
int iscons(int fd);


void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
void vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list);
int snprintf(char *str, int size, const char *fmt, ...);
int vsnprintf(char *str, int size, const char *fmt, va_list);


int cprintf(const char *fmt, ...);
int vcprintf(const char *fmt, va_list);


int printf(const char *fmt, ...);
int fprintf(int fd, const char *fmt, ...);
int vfprintf(int fd, const char *fmt, va_list);


char* readline(const char *prompt);
# 7 "/mnt/e/sec/6.828/lab/inc/assert.h" 2

void _warn(const char*, int, const char*, ...);
void _panic(const char*, int, const char*, ...) __attribute__((noreturn));
# 8 "kern/pmap.c" 2

# 1 "/mnt/e/sec/6.828/lab/kern/pmap.h" 1
# 9 "/mnt/e/sec/6.828/lab/kern/pmap.h"
# 1 "/mnt/e/sec/6.828/lab/inc/memlayout.h" 1
# 142 "/mnt/e/sec/6.828/lab/inc/memlayout.h"
typedef uint32_t pte_t;
typedef uint32_t pde_t;
# 174 "/mnt/e/sec/6.828/lab/inc/memlayout.h"
struct PageInfo {

 struct PageInfo *pp_link;






 uint16_t pp_ref;
};
# 10 "/mnt/e/sec/6.828/lab/kern/pmap.h" 2


extern char bootstacktop[], bootstack[];

extern struct PageInfo *pages;
extern size_t npages;

extern pde_t *kern_pgdir;
# 27 "/mnt/e/sec/6.828/lab/kern/pmap.h"
static inline physaddr_t
_paddr(const char *file, int line, void *kva)
{
 if ((uint32_t)kva < 0xF0000000)
  _panic(file, line, "PADDR called with invalid kva %08lx", kva);
 return (physaddr_t)kva - 0xF0000000;
}





static inline void*
_kaddr(const char *file, int line, physaddr_t pa)
{
 if ((((uintptr_t) (pa)) >> 12) >= npages)
  _panic(file, line, "KADDR called with invalid pa %08lx", pa);
 return (void *)(pa + 0xF0000000);
}


enum {

 ALLOC_ZERO = 1<<0,
};

void mem_init(void);

void page_init(void);
struct PageInfo *page_alloc(int alloc_flags);
void page_free(struct PageInfo *pp);
int page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm);
void page_remove(pde_t *pgdir, void *va);
struct PageInfo *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store);
void page_decref(struct PageInfo *pp);

void tlb_invalidate(pde_t *pgdir, void *va);

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
 return (pp - pages) << 12;
}


static inline struct PageInfo*
pa2page(physaddr_t pa)
{
 if ((((uintptr_t) (pa)) >> 12) >= npages)
  _panic("/mnt/e/sec/6.828/lab/kern/pmap.h", 76, "pa2page called with invalid pa");
 return &pages[(((uintptr_t) (pa)) >> 12)];
}

static inline void*
page2kva(struct PageInfo *pp)
{
 return _kaddr("/mnt/e/sec/6.828/lab/kern/pmap.h", 83, page2pa(pp));
}

pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create);
# 10 "kern/pmap.c" 2
# 1 "/mnt/e/sec/6.828/lab/kern/kclock.h" 1
# 26 "/mnt/e/sec/6.828/lab/kern/kclock.h"
unsigned mc146818_read(unsigned reg);
void mc146818_write(unsigned reg, unsigned datum);
# 11 "kern/pmap.c" 2


size_t npages;
static size_t npages_basemem;


pde_t *kern_pgdir;
struct PageInfo *pages;
static struct PageInfo *page_free_list;






static int
nvram_read(int r)
{
 return mc146818_read(r) | (mc146818_read(r + 1) << 8);
}

static void
i386_detect_memory(void)
{
 size_t basemem, extmem, ext16mem, totalmem;



 basemem = nvram_read((0xe + 7));
 extmem = nvram_read((0xe + 9));
 ext16mem = nvram_read((0xe + 38)) * 64;



 if (ext16mem)
  totalmem = 16 * 1024 + ext16mem;
 else if (extmem)
  totalmem = 1 * 1024 + extmem;
 else
  totalmem = basemem;

 npages = totalmem / (4096 / 1024);
 npages_basemem = basemem / (4096 / 1024);

 cprintf("Physical memory: %uK available, base = %uK, extended = %uK\n",
  totalmem, basemem, totalmem - basemem);
}






static void boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm);
static void check_page_free_list(bool only_low_memory);
static void check_page_alloc(void);
static void check_kern_pgdir(void);
static physaddr_t check_va2pa(pde_t *pgdir, uintptr_t va);
static void check_page(void);
static void check_page_installed_pgdir(void);
# 84 "kern/pmap.c"
static void *
boot_alloc(uint32_t n)
{
 static char *nextfree;
 char *result;






 if (!nextfree) {
  extern char end[];
  nextfree = ({ uint32_t __n = (uint32_t) (4096); (typeof((char *) end)) (({ uint32_t __a = (uint32_t) ((uint32_t) ((char *) end) + __n - 1); (typeof((uint32_t) ((char *) end) + __n - 1)) (__a - __a % (__n)); })); });
 }







    result = nextfree;
    if (n > 0)
    {
        nextfree = ({ uint32_t __n = (uint32_t) (4096); (typeof(nextfree + n)) (({ uint32_t __a = (uint32_t) ((uint32_t) (nextfree + n) + __n - 1); (typeof((uint32_t) (nextfree + n) + __n - 1)) (__a - __a % (__n)); })); });
        if (((uint32_t)nextfree - 0xF0000000) > (npages * 4096))
        {
            _panic("kern/pmap.c", 112, "boot_alloc: out of memory. Requested %uK, available %uK.\n", (uint32_t)nextfree / 1024, npages * 4096 / 1024);
        }
    }
    return result;
}
# 127 "kern/pmap.c"
void
mem_init(void)
{
 uint32_t cr0;
 size_t n;


 i386_detect_memory();



 kern_pgdir = (pde_t *) boot_alloc(4096);
 memset(kern_pgdir, 0, 4096);
# 148 "kern/pmap.c"
 kern_pgdir[((((uintptr_t) (((((0xF0000000 - (4096*1024)) - (4096*1024))) - (4096*1024)))) >> 22) & 0x3FF)] = _paddr("kern/pmap.c", 148, kern_pgdir) | 0x004 | 0x001;
# 158 "kern/pmap.c"
    pages = (struct PageInfo *) boot_alloc(npages * sizeof(struct PageInfo));
    memset(pages, 0, npages * sizeof(struct PageInfo));







 page_init();

 check_page_free_list(1);
 check_page_alloc();
 check_page();
# 184 "kern/pmap.c"
    boot_map_region(kern_pgdir, (((((0xF0000000 - (4096*1024)) - (4096*1024))) - (4096*1024)) - (4096*1024)), (4096*1024), _paddr("kern/pmap.c", 184, pages), 0x004);
# 215 "kern/pmap.c"
    uintptr_t backed_stack = 0xF0000000 - (8*4096);
    boot_map_region(kern_pgdir, backed_stack, (8*4096), _paddr("kern/pmap.c", 216, bootstack), 0x002);
# 230 "kern/pmap.c"
    uintptr_t pa_end = 0xFFFFFFFF - 0xF0000000 + 1;
    boot_map_region(kern_pgdir, 0xF0000000, pa_end, 0, 0x002);



 check_kern_pgdir();
# 244 "kern/pmap.c"
 lcr3(_paddr("kern/pmap.c", 244, kern_pgdir));

 check_page_free_list(0);



 cr0 = rcr0();
 cr0 |= 0x00000001|0x80000000|0x00040000|0x00010000|0x00000020|0x00000002;
 cr0 &= ~(0x00000008|0x00000004);
 lcr0(cr0);


 check_page_installed_pgdir();
}
# 271 "kern/pmap.c"
void
page_init(void)
{
# 291 "kern/pmap.c"
    size_t i;




    pages[0].pp_ref = 1;
    pages[0].pp_link = ((void*) 0);



    for (int i = 1; i < npages_basemem; i++)
    {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];
    }



    uint32_t first_free_pa = (uint32_t)_paddr("kern/pmap.c", 310, boot_alloc(0));
    do { if (!(first_free_pa % 4096 == 0)) _panic("kern/pmap.c", 311, "assertion failed: %s", "first_free_pa % PGSIZE == 0"); } while (0);
    int free_pa_pg_indx = first_free_pa / 4096;
    for (int i = npages_basemem; i < free_pa_pg_indx; i++)
    {
        pages[i].pp_ref = 1;
        pages[i].pp_link = ((void*) 0);
    }





    for (int i = free_pa_pg_indx; i < npages; i++)
    {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];
    }
}
# 343 "kern/pmap.c"
struct PageInfo *
page_alloc(int alloc_flags)
{

    struct PageInfo *pp;

    if (page_free_list == ((void*) 0))
    {
        return ((void*) 0);
    }

    pp = page_free_list;
    page_free_list = page_free_list->pp_link;
    pp->pp_link = ((void*) 0);

    if (alloc_flags & ALLOC_ZERO)
    {
        memset(page2kva(pp), 0, 4096);
    }

    return pp;
}





void
page_free(struct PageInfo *pp)
{




    if (pp->pp_ref != 0 || pp->pp_link != ((void*) 0))
    {
        _panic("kern/pmap.c", 379, "page_free: invalid page free attempt.\n");
    }

    pp->pp_link = page_free_list;
    page_free_list = pp;
}





void
page_decref(struct PageInfo* pp)
{
 if (--pp->pp_ref == 0)
  page_free(pp);
}
# 419 "kern/pmap.c"
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
    uintptr_t addr = (uintptr_t)va;
    pde_t pde = pgdir[((((uintptr_t) (addr)) >> 22) & 0x3FF)];



    if (!(pde & 0x001) && create)
    {
        struct PageInfo *pd_page = page_alloc(ALLOC_ZERO);
        if (!pd_page)
        {
            return ((void*) 0);
        }
        pd_page->pp_ref++;
        pde = page2pa(pd_page) | 0x002 | 0x001 | 0x004;
        pgdir[((((uintptr_t) (addr)) >> 22) & 0x3FF)] = pde;
    } else if (!(pde & 0x001))
    {
        return ((void*) 0);
    }

    physaddr_t pgtable_pa = ((physaddr_t) (pde) & ~0xFFF);
    pde_t *pgtable_va = _kaddr("kern/pmap.c", 443, pgtable_pa);
    return &pgtable_va[((((uintptr_t) (addr)) >> 12) & 0x3FF)];
}
# 458 "kern/pmap.c"
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{

    do { if (!(size % 4096 == 0)) _panic("kern/pmap.c", 462, "assertion failed: %s", "size % PGSIZE == 0"); } while (0);
    do { if (!(va % 4096 == 0)) _panic("kern/pmap.c", 463, "assertion failed: %s", "va % PGSIZE == 0"); } while (0);
    do { if (!(pa % 4096 == 0)) _panic("kern/pmap.c", 464, "assertion failed: %s", "pa % PGSIZE == 0"); } while (0);

    for (int i = 0, n = size / 4096; i < n; i++) {
        pte_t *pte = pgdir_walk(pgdir, (void *)(va + i * 4096), 1);
        if (!pte)
            _panic("kern/pmap.c", 469, "boot_map_region: pgdir_walk failed");
        *pte = (pa + i * 4096) | perm | 0x001;
    }

}
# 500 "kern/pmap.c"
int
page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
{
    pte_t *pte = pgdir_walk(pgdir, va, 1);
    if (!pte)
        return -E_NO_MEM;

    if (*pte & 0x001)
    {
        if (pa2page(((physaddr_t) (*pte) & ~0xFFF)) == pp)
        {
            if ((*pte & 0x1ff) == perm)
            {
                return 0;
            }
            *pte = page2pa(pp) | perm | 0x001;
            tlb_invalidate(pgdir, va);
            return 0;
        }
        page_remove(pgdir, va);
        do { if (!(*pte == 0)) _panic("kern/pmap.c", 520, "assertion failed: %s", "*pte == 0"); } while (0);
    }

    pp->pp_ref++;
    *pte = page2pa(pp) | perm | 0x001;
 return 0;
}
# 539 "kern/pmap.c"
struct PageInfo *
page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
    pte_t *pte = pgdir_walk(pgdir, va, 0);
    if (!pte || !(*pte & 0x001))
        return ((void*) 0);

    if (pte_store)
        *pte_store = pte;

    return pa2page(((physaddr_t) (*pte) & ~0xFFF));
}
# 567 "kern/pmap.c"
void
page_remove(pde_t *pgdir, void *va)
{

    pte_t *pte_store = ((void*) 0);
    struct PageInfo *pp = page_lookup(pgdir, va, &pte_store);
    if (!pp)
        return;

    *pte_store = 0;
    page_decref(pp);
    tlb_invalidate(pgdir, va);
}





void
tlb_invalidate(pde_t *pgdir, void *va)
{


 invlpg(va);
}
# 601 "kern/pmap.c"
static void
check_page_free_list(bool only_low_memory)
{
 struct PageInfo *pp;
 unsigned pdx_limit = only_low_memory ? 1 : 1024;
 int nfree_basemem = 0, nfree_extmem = 0;
 char *first_free_page;

 if (!page_free_list)
  _panic("kern/pmap.c", 610, "'page_free_list' is a null pointer!");

 if (only_low_memory) {


  struct PageInfo *pp1, *pp2;
  struct PageInfo **tp[2] = { &pp1, &pp2 };
  for (pp = page_free_list; pp; pp = pp->pp_link) {
   int pagetype = ((((uintptr_t) (page2pa(pp))) >> 22) & 0x3FF) >= pdx_limit;
   *tp[pagetype] = pp;
   tp[pagetype] = &pp->pp_link;
  }
  *tp[1] = 0;
  *tp[0] = pp2;
  page_free_list = pp1;
 }



 for (pp = page_free_list; pp; pp = pp->pp_link)
  if (((((uintptr_t) (page2pa(pp))) >> 22) & 0x3FF) < pdx_limit)
   memset(page2kva(pp), 0x97, 128);

 first_free_page = (char *) boot_alloc(0);
 for (pp = page_free_list; pp; pp = pp->pp_link) {

  do { if (!(pp >= pages)) _panic("kern/pmap.c", 636, "assertion failed: %s", "pp >= pages"); } while (0);
  do { if (!(pp < pages + npages)) _panic("kern/pmap.c", 637, "assertion failed: %s", "pp < pages + npages"); } while (0);
  do { if (!(((char *) pp - (char *) pages) % sizeof(*pp) == 0)) _panic("kern/pmap.c", 638, "assertion failed: %s", "((char *) pp - (char *) pages) % sizeof(*pp) == 0"); } while (0);


  do { if (!(page2pa(pp) != 0)) _panic("kern/pmap.c", 641, "assertion failed: %s", "page2pa(pp) != 0"); } while (0);
  do { if (!(page2pa(pp) != 0x0A0000)) _panic("kern/pmap.c", 642, "assertion failed: %s", "page2pa(pp) != IOPHYSMEM"); } while (0);
  do { if (!(page2pa(pp) != 0x100000 - 4096)) _panic("kern/pmap.c", 643, "assertion failed: %s", "page2pa(pp) != EXTPHYSMEM - PGSIZE"); } while (0);
  do { if (!(page2pa(pp) != 0x100000)) _panic("kern/pmap.c", 644, "assertion failed: %s", "page2pa(pp) != EXTPHYSMEM"); } while (0);
  do { if (!(page2pa(pp) < 0x100000 || (char *) page2kva(pp) >= first_free_page)) _panic("kern/pmap.c", 645, "assertion failed: %s", "page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page"); } while (0);

  if (page2pa(pp) < 0x100000)
   ++nfree_basemem;
  else
   ++nfree_extmem;
 }

 do { if (!(nfree_basemem > 0)) _panic("kern/pmap.c", 653, "assertion failed: %s", "nfree_basemem > 0"); } while (0);
 do { if (!(nfree_extmem > 0)) _panic("kern/pmap.c", 654, "assertion failed: %s", "nfree_extmem > 0"); } while (0);

 cprintf("check_page_free_list() succeeded!\n");
}





static void
check_page_alloc(void)
{
 struct PageInfo *pp, *pp0, *pp1, *pp2;
 int nfree;
 struct PageInfo *fl;
 char *c;
 int i;

 if (!pages)
  _panic("kern/pmap.c", 673, "'pages' is a null pointer!");


 for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
  ++nfree;


 pp0 = pp1 = pp2 = 0;
 do { if (!((pp0 = page_alloc(0)))) _panic("kern/pmap.c", 681, "assertion failed: %s", "(pp0 = page_alloc(0))"); } while (0);
 do { if (!((pp1 = page_alloc(0)))) _panic("kern/pmap.c", 682, "assertion failed: %s", "(pp1 = page_alloc(0))"); } while (0);
 do { if (!((pp2 = page_alloc(0)))) _panic("kern/pmap.c", 683, "assertion failed: %s", "(pp2 = page_alloc(0))"); } while (0);

 do { if (!(pp0)) _panic("kern/pmap.c", 685, "assertion failed: %s", "pp0"); } while (0);
 do { if (!(pp1 && pp1 != pp0)) _panic("kern/pmap.c", 686, "assertion failed: %s", "pp1 && pp1 != pp0"); } while (0);
 do { if (!(pp2 && pp2 != pp1 && pp2 != pp0)) _panic("kern/pmap.c", 687, "assertion failed: %s", "pp2 && pp2 != pp1 && pp2 != pp0"); } while (0);
 do { if (!(page2pa(pp0) < npages*4096)) _panic("kern/pmap.c", 688, "assertion failed: %s", "page2pa(pp0) < npages*PGSIZE"); } while (0);
 do { if (!(page2pa(pp1) < npages*4096)) _panic("kern/pmap.c", 689, "assertion failed: %s", "page2pa(pp1) < npages*PGSIZE"); } while (0);
 do { if (!(page2pa(pp2) < npages*4096)) _panic("kern/pmap.c", 690, "assertion failed: %s", "page2pa(pp2) < npages*PGSIZE"); } while (0);


 fl = page_free_list;
 page_free_list = 0;


 do { if (!(!page_alloc(0))) _panic("kern/pmap.c", 697, "assertion failed: %s", "!page_alloc(0)"); } while (0);


 page_free(pp0);
 page_free(pp1);
 page_free(pp2);
 pp0 = pp1 = pp2 = 0;
 do { if (!((pp0 = page_alloc(0)))) _panic("kern/pmap.c", 704, "assertion failed: %s", "(pp0 = page_alloc(0))"); } while (0);
 do { if (!((pp1 = page_alloc(0)))) _panic("kern/pmap.c", 705, "assertion failed: %s", "(pp1 = page_alloc(0))"); } while (0);
 do { if (!((pp2 = page_alloc(0)))) _panic("kern/pmap.c", 706, "assertion failed: %s", "(pp2 = page_alloc(0))"); } while (0);
 do { if (!(pp0)) _panic("kern/pmap.c", 707, "assertion failed: %s", "pp0"); } while (0);
 do { if (!(pp1 && pp1 != pp0)) _panic("kern/pmap.c", 708, "assertion failed: %s", "pp1 && pp1 != pp0"); } while (0);
 do { if (!(pp2 && pp2 != pp1 && pp2 != pp0)) _panic("kern/pmap.c", 709, "assertion failed: %s", "pp2 && pp2 != pp1 && pp2 != pp0"); } while (0);
 do { if (!(!page_alloc(0))) _panic("kern/pmap.c", 710, "assertion failed: %s", "!page_alloc(0)"); } while (0);


 memset(page2kva(pp0), 1, 4096);
 page_free(pp0);
 do { if (!((pp = page_alloc(ALLOC_ZERO)))) _panic("kern/pmap.c", 715, "assertion failed: %s", "(pp = page_alloc(ALLOC_ZERO))"); } while (0);
 do { if (!(pp && pp0 == pp)) _panic("kern/pmap.c", 716, "assertion failed: %s", "pp && pp0 == pp"); } while (0);
 c = page2kva(pp);
 for (i = 0; i < 4096; i++)
  do { if (!(c[i] == 0)) _panic("kern/pmap.c", 719, "assertion failed: %s", "c[i] == 0"); } while (0);


 page_free_list = fl;


 page_free(pp0);
 page_free(pp1);
 page_free(pp2);


 for (pp = page_free_list; pp; pp = pp->pp_link)
  --nfree;
 do { if (!(nfree == 0)) _panic("kern/pmap.c", 732, "assertion failed: %s", "nfree == 0"); } while (0);

 cprintf("check_page_alloc() succeeded!\n");
}
# 745 "kern/pmap.c"
static void
check_kern_pgdir(void)
{
 uint32_t i, n;
 pde_t *pgdir;

 pgdir = kern_pgdir;


 n = ({ uint32_t __n = (uint32_t) (4096); (typeof(npages*sizeof(struct PageInfo))) (({ uint32_t __a = (uint32_t) ((uint32_t) (npages*sizeof(struct PageInfo)) + __n - 1); (typeof((uint32_t) (npages*sizeof(struct PageInfo)) + __n - 1)) (__a - __a % (__n)); })); });
 for (i = 0; i < n; i += 4096)
  do { if (!(check_va2pa(pgdir, (((((0xF0000000 - (4096*1024)) - (4096*1024))) - (4096*1024)) - (4096*1024)) + i) == _paddr("kern/pmap.c", 756, pages) + i)) _panic("kern/pmap.c", 756, "assertion failed: %s", "check_va2pa(pgdir, UPAGES + i) == PADDR(pages) + i"); } while (0);



 for (i = 0; i < npages * 4096; i += 4096)
  do { if (!(check_va2pa(pgdir, 0xF0000000 + i) == i)) _panic("kern/pmap.c", 761, "assertion failed: %s", "check_va2pa(pgdir, KERNBASE + i) == i"); } while (0);


 for (i = 0; i < (8*4096); i += 4096)
  do { if (!(check_va2pa(pgdir, 0xF0000000 - (8*4096) + i) == _paddr("kern/pmap.c", 765, bootstack) + i)) _panic("kern/pmap.c", 765, "assertion failed: %s", "check_va2pa(pgdir, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i"); } while (0);
 do { if (!(check_va2pa(pgdir, 0xF0000000 - (4096*1024)) == ~0)) _panic("kern/pmap.c", 766, "assertion failed: %s", "check_va2pa(pgdir, KSTACKTOP - PTSIZE) == ~0"); } while (0);


 for (i = 0; i < 1024; i++) {
  switch (i) {
  case ((((uintptr_t) (((((0xF0000000 - (4096*1024)) - (4096*1024))) - (4096*1024)))) >> 22) & 0x3FF):
  case ((((uintptr_t) (0xF0000000 -1)) >> 22) & 0x3FF):
  case ((((uintptr_t) ((((((0xF0000000 - (4096*1024)) - (4096*1024))) - (4096*1024)) - (4096*1024)))) >> 22) & 0x3FF):
   do { if (!(pgdir[i] & 0x001)) _panic("kern/pmap.c", 774, "assertion failed: %s", "pgdir[i] & PTE_P"); } while (0);
   break;
  default:
   if (i >= ((((uintptr_t) (0xF0000000)) >> 22) & 0x3FF)) {
    do { if (!(pgdir[i] & 0x001)) _panic("kern/pmap.c", 778, "assertion failed: %s", "pgdir[i] & PTE_P"); } while (0);
    do { if (!(pgdir[i] & 0x002)) _panic("kern/pmap.c", 779, "assertion failed: %s", "pgdir[i] & PTE_W"); } while (0);
   } else
    do { if (!(pgdir[i] == 0)) _panic("kern/pmap.c", 781, "assertion failed: %s", "pgdir[i] == 0"); } while (0);
   break;
  }
 }
 cprintf("check_kern_pgdir() succeeded!\n");
}






static physaddr_t
check_va2pa(pde_t *pgdir, uintptr_t va)
{
 pte_t *p;

 pgdir = &pgdir[((((uintptr_t) (va)) >> 22) & 0x3FF)];
 if (!(*pgdir & 0x001))
  return ~0;
 p = (pte_t*) _kaddr("kern/pmap.c", 801, ((physaddr_t) (*pgdir) & ~0xFFF));
 if (!(p[((((uintptr_t) (va)) >> 12) & 0x3FF)] & 0x001))
  return ~0;
 return ((physaddr_t) (p[((((uintptr_t) (va)) >> 12) & 0x3FF)]) & ~0xFFF);
}



static void
check_page(void)
{
 struct PageInfo *pp, *pp0, *pp1, *pp2;
 struct PageInfo *fl;
 pte_t *ptep, *ptep1;
 void *va;
 int i;
 extern pde_t entry_pgdir[];


 pp0 = pp1 = pp2 = 0;
 do { if (!((pp0 = page_alloc(0)))) _panic("kern/pmap.c", 821, "assertion failed: %s", "(pp0 = page_alloc(0))"); } while (0);
 do { if (!((pp1 = page_alloc(0)))) _panic("kern/pmap.c", 822, "assertion failed: %s", "(pp1 = page_alloc(0))"); } while (0);
 do { if (!((pp2 = page_alloc(0)))) _panic("kern/pmap.c", 823, "assertion failed: %s", "(pp2 = page_alloc(0))"); } while (0);

 do { if (!(pp0)) _panic("kern/pmap.c", 825, "assertion failed: %s", "pp0"); } while (0);
 do { if (!(pp1 && pp1 != pp0)) _panic("kern/pmap.c", 826, "assertion failed: %s", "pp1 && pp1 != pp0"); } while (0);
 do { if (!(pp2 && pp2 != pp1 && pp2 != pp0)) _panic("kern/pmap.c", 827, "assertion failed: %s", "pp2 && pp2 != pp1 && pp2 != pp0"); } while (0);


 fl = page_free_list;
 page_free_list = 0;


 do { if (!(!page_alloc(0))) _panic("kern/pmap.c", 834, "assertion failed: %s", "!page_alloc(0)"); } while (0);


 do { if (!(page_lookup(kern_pgdir, (void *) 0x0, &ptep) == ((void*) 0))) _panic("kern/pmap.c", 837, "assertion failed: %s", "page_lookup(kern_pgdir, (void *) 0x0, &ptep) == NULL"); } while (0);


 do { if (!(page_insert(kern_pgdir, pp1, 0x0, 0x002) < 0)) _panic("kern/pmap.c", 840, "assertion failed: %s", "page_insert(kern_pgdir, pp1, 0x0, PTE_W) < 0"); } while (0);


 page_free(pp0);
 do { if (!(page_insert(kern_pgdir, pp1, 0x0, 0x002) == 0)) _panic("kern/pmap.c", 844, "assertion failed: %s", "page_insert(kern_pgdir, pp1, 0x0, PTE_W) == 0"); } while (0);
 do { if (!(((physaddr_t) (kern_pgdir[0]) & ~0xFFF) == page2pa(pp0))) _panic("kern/pmap.c", 845, "assertion failed: %s", "PTE_ADDR(kern_pgdir[0]) == page2pa(pp0)"); } while (0);
 do { if (!(check_va2pa(kern_pgdir, 0x0) == page2pa(pp1))) _panic("kern/pmap.c", 846, "assertion failed: %s", "check_va2pa(kern_pgdir, 0x0) == page2pa(pp1)"); } while (0);
 do { if (!(pp1->pp_ref == 1)) _panic("kern/pmap.c", 847, "assertion failed: %s", "pp1->pp_ref == 1"); } while (0);
 do { if (!(pp0->pp_ref == 1)) _panic("kern/pmap.c", 848, "assertion failed: %s", "pp0->pp_ref == 1"); } while (0);


 do { if (!(page_insert(kern_pgdir, pp2, (void*) 4096, 0x002) == 0)) _panic("kern/pmap.c", 851, "assertion failed: %s", "page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0"); } while (0);
 do { if (!(check_va2pa(kern_pgdir, 4096) == page2pa(pp2))) _panic("kern/pmap.c", 852, "assertion failed: %s", "check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2)"); } while (0);
 do { if (!(pp2->pp_ref == 1)) _panic("kern/pmap.c", 853, "assertion failed: %s", "pp2->pp_ref == 1"); } while (0);


 do { if (!(!page_alloc(0))) _panic("kern/pmap.c", 856, "assertion failed: %s", "!page_alloc(0)"); } while (0);


 do { if (!(page_insert(kern_pgdir, pp2, (void*) 4096, 0x002) == 0)) _panic("kern/pmap.c", 859, "assertion failed: %s", "page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0"); } while (0);
 do { if (!(check_va2pa(kern_pgdir, 4096) == page2pa(pp2))) _panic("kern/pmap.c", 860, "assertion failed: %s", "check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2)"); } while (0);
 do { if (!(pp2->pp_ref == 1)) _panic("kern/pmap.c", 861, "assertion failed: %s", "pp2->pp_ref == 1"); } while (0);



 do { if (!(!page_alloc(0))) _panic("kern/pmap.c", 865, "assertion failed: %s", "!page_alloc(0)"); } while (0);


 ptep = (pte_t *) _kaddr("kern/pmap.c", 868, ((physaddr_t) (kern_pgdir[((((uintptr_t) (4096)) >> 22) & 0x3FF)]) & ~0xFFF));
 do { if (!(pgdir_walk(kern_pgdir, (void*)4096, 0) == ptep+((((uintptr_t) (4096)) >> 12) & 0x3FF))) _panic("kern/pmap.c", 869, "assertion failed: %s", "pgdir_walk(kern_pgdir, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE)"); } while (0);


 do { if (!(page_insert(kern_pgdir, pp2, (void*) 4096, 0x002|0x004) == 0)) _panic("kern/pmap.c", 872, "assertion failed: %s", "page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W|PTE_U) == 0"); } while (0);
 do { if (!(check_va2pa(kern_pgdir, 4096) == page2pa(pp2))) _panic("kern/pmap.c", 873, "assertion failed: %s", "check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2)"); } while (0);
 do { if (!(pp2->pp_ref == 1)) _panic("kern/pmap.c", 874, "assertion failed: %s", "pp2->pp_ref == 1"); } while (0);
 do { if (!(*pgdir_walk(kern_pgdir, (void*) 4096, 0) & 0x004)) _panic("kern/pmap.c", 875, "assertion failed: %s", "*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U"); } while (0);
 do { if (!(kern_pgdir[0] & 0x004)) _panic("kern/pmap.c", 876, "assertion failed: %s", "kern_pgdir[0] & PTE_U"); } while (0);


 do { if (!(page_insert(kern_pgdir, pp2, (void*) 4096, 0x002) == 0)) _panic("kern/pmap.c", 879, "assertion failed: %s", "page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0"); } while (0);
 do { if (!(*pgdir_walk(kern_pgdir, (void*) 4096, 0) & 0x002)) _panic("kern/pmap.c", 880, "assertion failed: %s", "*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_W"); } while (0);
 do { if (!(!(*pgdir_walk(kern_pgdir, (void*) 4096, 0) & 0x004))) _panic("kern/pmap.c", 881, "assertion failed: %s", "!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U)"); } while (0);


 do { if (!(page_insert(kern_pgdir, pp0, (void*) (4096*1024), 0x002) < 0)) _panic("kern/pmap.c", 884, "assertion failed: %s", "page_insert(kern_pgdir, pp0, (void*) PTSIZE, PTE_W) < 0"); } while (0);


 do { if (!(page_insert(kern_pgdir, pp1, (void*) 4096, 0x002) == 0)) _panic("kern/pmap.c", 887, "assertion failed: %s", "page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W) == 0"); } while (0);
 do { if (!(!(*pgdir_walk(kern_pgdir, (void*) 4096, 0) & 0x004))) _panic("kern/pmap.c", 888, "assertion failed: %s", "!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U)"); } while (0);


 do { if (!(check_va2pa(kern_pgdir, 0) == page2pa(pp1))) _panic("kern/pmap.c", 891, "assertion failed: %s", "check_va2pa(kern_pgdir, 0) == page2pa(pp1)"); } while (0);
 do { if (!(check_va2pa(kern_pgdir, 4096) == page2pa(pp1))) _panic("kern/pmap.c", 892, "assertion failed: %s", "check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1)"); } while (0);

 do { if (!(pp1->pp_ref == 2)) _panic("kern/pmap.c", 894, "assertion failed: %s", "pp1->pp_ref == 2"); } while (0);
 do { if (!(pp2->pp_ref == 0)) _panic("kern/pmap.c", 895, "assertion failed: %s", "pp2->pp_ref == 0"); } while (0);


 do { if (!((pp = page_alloc(0)) && pp == pp2)) _panic("kern/pmap.c", 898, "assertion failed: %s", "(pp = page_alloc(0)) && pp == pp2"); } while (0);


 page_remove(kern_pgdir, 0x0);
 do { if (!(check_va2pa(kern_pgdir, 0x0) == ~0)) _panic("kern/pmap.c", 902, "assertion failed: %s", "check_va2pa(kern_pgdir, 0x0) == ~0"); } while (0);
 do { if (!(check_va2pa(kern_pgdir, 4096) == page2pa(pp1))) _panic("kern/pmap.c", 903, "assertion failed: %s", "check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1)"); } while (0);
 do { if (!(pp1->pp_ref == 1)) _panic("kern/pmap.c", 904, "assertion failed: %s", "pp1->pp_ref == 1"); } while (0);
 do { if (!(pp2->pp_ref == 0)) _panic("kern/pmap.c", 905, "assertion failed: %s", "pp2->pp_ref == 0"); } while (0);


 do { if (!(page_insert(kern_pgdir, pp1, (void*) 4096, 0) == 0)) _panic("kern/pmap.c", 908, "assertion failed: %s", "page_insert(kern_pgdir, pp1, (void*) PGSIZE, 0) == 0"); } while (0);
 do { if (!(pp1->pp_ref)) _panic("kern/pmap.c", 909, "assertion failed: %s", "pp1->pp_ref"); } while (0);
 do { if (!(pp1->pp_link == ((void*) 0))) _panic("kern/pmap.c", 910, "assertion failed: %s", "pp1->pp_link == NULL"); } while (0);


 page_remove(kern_pgdir, (void*) 4096);
 do { if (!(check_va2pa(kern_pgdir, 0x0) == ~0)) _panic("kern/pmap.c", 914, "assertion failed: %s", "check_va2pa(kern_pgdir, 0x0) == ~0"); } while (0);
 do { if (!(check_va2pa(kern_pgdir, 4096) == ~0)) _panic("kern/pmap.c", 915, "assertion failed: %s", "check_va2pa(kern_pgdir, PGSIZE) == ~0"); } while (0);
 do { if (!(pp1->pp_ref == 0)) _panic("kern/pmap.c", 916, "assertion failed: %s", "pp1->pp_ref == 0"); } while (0);
 do { if (!(pp2->pp_ref == 0)) _panic("kern/pmap.c", 917, "assertion failed: %s", "pp2->pp_ref == 0"); } while (0);


 do { if (!((pp = page_alloc(0)) && pp == pp1)) _panic("kern/pmap.c", 920, "assertion failed: %s", "(pp = page_alloc(0)) && pp == pp1"); } while (0);


 do { if (!(!page_alloc(0))) _panic("kern/pmap.c", 923, "assertion failed: %s", "!page_alloc(0)"); } while (0);


 do { if (!(((physaddr_t) (kern_pgdir[0]) & ~0xFFF) == page2pa(pp0))) _panic("kern/pmap.c", 926, "assertion failed: %s", "PTE_ADDR(kern_pgdir[0]) == page2pa(pp0)"); } while (0);
 kern_pgdir[0] = 0;
 do { if (!(pp0->pp_ref == 1)) _panic("kern/pmap.c", 928, "assertion failed: %s", "pp0->pp_ref == 1"); } while (0);
 pp0->pp_ref = 0;


 page_free(pp0);
 va = (void*)(4096 * 1024 + 4096);
 ptep = pgdir_walk(kern_pgdir, va, 1);
 ptep1 = (pte_t *) _kaddr("kern/pmap.c", 935, ((physaddr_t) (kern_pgdir[((((uintptr_t) (va)) >> 22) & 0x3FF)]) & ~0xFFF));
 do { if (!(ptep == ptep1 + ((((uintptr_t) (va)) >> 12) & 0x3FF))) _panic("kern/pmap.c", 936, "assertion failed: %s", "ptep == ptep1 + PTX(va)"); } while (0);
 kern_pgdir[((((uintptr_t) (va)) >> 22) & 0x3FF)] = 0;
 pp0->pp_ref = 0;


 memset(page2kva(pp0), 0xFF, 4096);
 page_free(pp0);
 pgdir_walk(kern_pgdir, 0x0, 1);
 ptep = (pte_t *) page2kva(pp0);
 for(i=0; i<1024; i++)
  do { if (!((ptep[i] & 0x001) == 0)) _panic("kern/pmap.c", 946, "assertion failed: %s", "(ptep[i] & PTE_P) == 0"); } while (0);
 kern_pgdir[0] = 0;
 pp0->pp_ref = 0;


 page_free_list = fl;


 page_free(pp0);
 page_free(pp1);
 page_free(pp2);

 cprintf("check_page() succeeded!\n");
}


static void
check_page_installed_pgdir(void)
{
 struct PageInfo *pp, *pp0, *pp1, *pp2;
 struct PageInfo *fl;
 pte_t *ptep, *ptep1;
 uintptr_t va;
 int i;


 pp1 = pp2 = 0;
 do { if (!((pp0 = page_alloc(0)))) _panic("kern/pmap.c", 973, "assertion failed: %s", "(pp0 = page_alloc(0))"); } while (0);
 do { if (!((pp1 = page_alloc(0)))) _panic("kern/pmap.c", 974, "assertion failed: %s", "(pp1 = page_alloc(0))"); } while (0);
 do { if (!((pp2 = page_alloc(0)))) _panic("kern/pmap.c", 975, "assertion failed: %s", "(pp2 = page_alloc(0))"); } while (0);
 page_free(pp0);
 memset(page2kva(pp1), 1, 4096);
 memset(page2kva(pp2), 2, 4096);
 page_insert(kern_pgdir, pp1, (void*) 4096, 0x002);
 do { if (!(pp1->pp_ref == 1)) _panic("kern/pmap.c", 980, "assertion failed: %s", "pp1->pp_ref == 1"); } while (0);
 do { if (!(*(uint32_t *)4096 == 0x01010101U)) _panic("kern/pmap.c", 981, "assertion failed: %s", "*(uint32_t *)PGSIZE == 0x01010101U"); } while (0);
 page_insert(kern_pgdir, pp2, (void*) 4096, 0x002);
 do { if (!(*(uint32_t *)4096 == 0x02020202U)) _panic("kern/pmap.c", 983, "assertion failed: %s", "*(uint32_t *)PGSIZE == 0x02020202U"); } while (0);
 do { if (!(pp2->pp_ref == 1)) _panic("kern/pmap.c", 984, "assertion failed: %s", "pp2->pp_ref == 1"); } while (0);
 do { if (!(pp1->pp_ref == 0)) _panic("kern/pmap.c", 985, "assertion failed: %s", "pp1->pp_ref == 0"); } while (0);
 *(uint32_t *)4096 = 0x03030303U;
 do { if (!(*(uint32_t *)page2kva(pp2) == 0x03030303U)) _panic("kern/pmap.c", 987, "assertion failed: %s", "*(uint32_t *)page2kva(pp2) == 0x03030303U"); } while (0);
 page_remove(kern_pgdir, (void*) 4096);
 do { if (!(pp2->pp_ref == 0)) _panic("kern/pmap.c", 989, "assertion failed: %s", "pp2->pp_ref == 0"); } while (0);


 do { if (!(((physaddr_t) (kern_pgdir[0]) & ~0xFFF) == page2pa(pp0))) _panic("kern/pmap.c", 992, "assertion failed: %s", "PTE_ADDR(kern_pgdir[0]) == page2pa(pp0)"); } while (0);
 kern_pgdir[0] = 0;
 do { if (!(pp0->pp_ref == 1)) _panic("kern/pmap.c", 994, "assertion failed: %s", "pp0->pp_ref == 1"); } while (0);
 pp0->pp_ref = 0;


 page_free(pp0);

 cprintf("check_page_installed_pgdir() succeeded!\n");
}
